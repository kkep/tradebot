import { Trade } from '../binance-api/services/api/v3/trade';
import { TimeInForce } from '../binance-api/enums/TimeInForce';
import { Cache } from 'cache-manager';
import { ExchangeInfoSymbolDto } from '../binance-api/dto/exchangeInfoSymbol.dto';
import { Subscription } from '../entities/subscription.entity';
import { Order } from '../entities/order.entity';
import { Repository } from 'typeorm';
import { Strategy } from '../entities/strategy.entity';
export declare class TradeService<P> {
    subscription: Subscription;
    private cacheManager;
    private orderRepository;
    private strategyRepository;
    private client;
    private params;
    private service;
    constructor(subscription: Subscription, cacheManager: Cache, orderRepository: Repository<Order>, strategyRepository: Repository<Strategy>);
    buy(symbol: string, price: number, quantity: number): Promise<import("axios").AxiosResponse<any, any>>;
    buyLimit(symbol: string, price: number, quantity: number): Promise<void>;
    buyMarket(symbol: string, quantity: number): Promise<void>;
    sellLimit(symbol: string, price: number, quantity: number): Promise<void>;
    firstBuy(symbol: string, price: number): Promise<void>;
    getTakeProfit(symbol: string, price: number): Promise<number>;
    getBalanceBaseAssetQuantity(exchangeInfo: any): Promise<number>;
    getService(): Trade;
    getOptions(symbol: string, price: number, quantity: number): {
        recvWindow: number;
        timeInForce: TimeInForce;
        quantity: number;
        newOrderRespType: string;
    };
    getOrders(symbol: string): Promise<import("axios").AxiosResponse<any, any>>;
    cancelOrder(symbol: string, orderId?: number, origClientOrderId?: number | string): Promise<import("axios").AxiosResponse<any, any>>;
    checkOrders(symbol: string, price: number): Promise<void>;
    getExchangeInfo(): Promise<ExchangeInfoSymbolDto[]>;
    filterExchangeInfo(symbol: string, filterName: string): Promise<{
        filterType: "PRICE_FILTER" | "LOT_SIZE" | "ICEBERG_PARTS" | "MARKET_LOT_SIZE" | "TRAILING_DELTA" | "PERCENT_PRICE_BY_SIDE" | "NOTIONAL" | "MAX_NUM_ORDERS" | "MAX_NUM_ALGO_ORDERS";
        minPrice: number;
        maxPrice: number;
        tickSize: number;
        minQty: number;
        maxQty: number;
        limit: number;
        stepSize: number;
        minTrailingAboveDelta: number;
        maxTrailingAboveDelta: number;
        minTrailingBelowDelta: number;
        maxTrailingBelowDelta: number;
        bidMultiplierUp: number;
        bidMultiplierDown: number;
        askMultiplierUp: number;
        askMultiplierDown: number;
        avgPriceMins: number;
        minNotional: number;
        applyMinToMarket: true;
        maxNotional: number;
        applyMaxToMarket: false;
        maxNumAlgoOrders: number;
        maxNumOrders: number;
    }>;
    gridBuy(symbol: string, price: number): Promise<void>;
    fixQuantity(symbol: any, quantity: number): Promise<number>;
    private getWallet;
    getPrecision(tickSize: number | string): number;
    getBalanceAsset(asset: string): Promise<any>;
    getExchangeInfoBySymbol(symbol: string): Promise<ExchangeInfoSymbolDto>;
    getTakeProfitByOrders(symbol: string, orders: Array<Order>): Promise<number>;
}
